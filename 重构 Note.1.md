*WHEN?*

### 一些代码的坏味道

**Duplicated Code （重复代码）**

1. 相同的代码: 提取出来
2. 相似的代码: 分离相似和差异部分，提取出相似部分
3. 不同的算法，同样的工作：用最清晰的那个算法代替其他所有

**Long Method （过长函数）**

1. 短小的函数更长寿，顺便给短函数取个好名字，好让它一目了然。
2. 积极得分解函数。当你觉得需要注释的时候，你应该把需要说明的东西写进一个独立函数中，并以其用途（!而非实现手法）命名。
3. 检索函数中的注释处，流程控制处，这些往往是十分需要分解的地方。

**Large Class （过大的类）**

*PS: 类在我的日常语言里面用得比较少，所以我换个思路*

1. 一个模块内包含的方法和引用的依赖过多的时候，适当得分解成多个模块。
2. 内部消化掉模块中的重复代码，将“五个百行函数”整理成五个“十行函数”和十个提炼出来的“双行函数”。
3. 先确定消费者需要的接口，从这个角度出发或许能够帮助你看清如何分解这个模块。
4. 如果是一些GUI类，你可能需要在多处时候重复的数据，你使用*观察者模式*, *P/S模式*等可以把这些数据独立出来供视图消费。

**Long Parameter List（过长参数列）**

Personal Point: 现代编程语言，基本上至少都具备闭包或面向对象的能力，不容易出现过长参数列这种情况。除非你发现了你的参数经常变动(这大概就是设计上有误)，除此之外基本上不需要担心什么。

**Divergent Change（发散式变化）**

> 我们**希望**软件能够更容易被修改——毕竟软件再怎么说本来就该是**软**的。一旦修改，我们希望能够跳到系统的某一点，只在该出做修改，如果做不到这一点，你就能嗅出两种刺鼻味道中的一中了。

*发散式修改*: 如果一个类中的不同部分，会因为不同方向的修改产生调整，那么就应该试图运用*Extract Class(149)*去把不同部分的内容分离出来，尽量一个类只针对某一个外界变化。

**Shotgun Surgery（霰弹式修改）**

这个情况类似前者，但恰恰相反。 如果每遇到外界变化，所需要修改的代码遍布各处；这样的话不但很难找到它们，还很容易忘记某个重要的改动。

这时，应该将这些需要修改的方法和字段放入同一个类中。如果眼下没有适合存放的类，那就创造一个。TODO: What is *Inline Class* ?

此状况和前者的原则是一样的：使“外界变化”与“需要修改的类”趋于一一对应。

**Feature Envy（依赖情结）**

>  对象技术的全部要点在于：这是一种“将数据和对数据的操作行为包装在一起”的技术。因此，自然而然会有一种经典气味：函数对某个类的兴趣高过对自己所处类的兴趣。

1. 在扩展类的时候及时得进行调整，如果发现了有某些函数更依赖于其他类的数据，那就把他移动过去。
2. 在更复杂的情况下，可以借助一些设计模式去弥补语言上的不足，如：GoF的Strategy和Visitor, KentBeck的Self Delegation。
3. 根本原则：把需要变化的数据和行为绑定在一起，如果有例外，我们就搬移那些行为，保持变化只在一地发生。

**Data Clumps（数据泥团）**

1. 数据项经常会因为内在联系成群结队得待在一起，这时候就应该把这部分数据提取出一个新类，并着手于寻找Feature Envy, 重新梳理程序结构。
2. 一个好的评判方法：删掉众多数据的一项。这么做，其他数据有没有因而失去意义？

**Primitive Obsession（基本类型偏执）**

1. 用小对象代替基本类型，如Range, Phone, ZIP, Money等
2. 用小对象代替Array，字段集合，参数列(Introduce Parameter Object?)等

**Switch Statements**

用多态代替Switch, 除非是单一函数中稍微用一下switch做流程控制

